#include <iostream>
#include <math.h>
using namespace std;

// класс точка в декартовой системе координат
// класс - это пользовательский тип данных - пользователь - это разработчик
//,тоже самое мы делаем, когда создаем переменную, например int a,
class Point {
// поля -> переменны
// методы -> функции
// модификатор public, private
// по умолчанию все свойства - private
// конструктор, деструктор
// protected: -> модефикатор, котрый открывает доступ к членам класса дружественным и дочерним классам.
private: // нельзя добраться до свойств вне класса
    // private ~ инкапсуляция ( помните о капсуле)
    // get -- получить данные
    // set -- установить данные
    // вместо этого обычно используется конструктор
    // Инкапсуляция – это механизм программирования, который связывает воедино код и данные,
    // которые он обрабатывает, чтобы обезопасить их от внешнего воздействия и от неправильного использования.
    int x_;
    int y_;
    int z_;
    int* arg ; // пример для деструктора -> далее будет
    // ключевое слово this ! - компилятор делает его за нас в методах, это ключевое слово ведет к объекту через адрес( адрес обьйекта )
public: // можно добраться до свойств вне класса
    // конструктор должен быть в public !
    Point(int x, int y, int z){
        x_=x;
        y_=y;
        z_=z;


        arg = new int[3];
    }; // констркутор дает возможность не писать 150 сеттеров и геттеров
    int GetX(){
        return x_;
    }
    int GetY(){
        return y_;
    }
    int GetZ(){
        return z_;
    }
    int setX(int x){
        this ->x_ = x; // в данном примере x_ отличается от x, поэтому this визуально не нужен
    }
    int Length(){
        int L = sqrt(x_*x_ + y_*y_ + z_*z_);
        return L;
    }
    // деструктор обычно сам компилируется компилятором, он бесполезен в большинтсве случаев
    // для динамической памяти он обязателен,  так как поля прайвет, то следовательно и удалить их нельзя вне класса
    ~Point(){
        // тем самым утечки памяти не произойдет
    delete[] arg;
    };
public:
    // конструктор копирования
    // если мы скопируем объект с динамическими полями, то произойдет ошибка из-за того, что компилятор не сможет удалить два раза одни и те же данные
  Point (const Point &other){ // объект по ссылке передается
        this -> x_ = other.x_;
        this -> arg = new int[3]; // создался новый массив для новго скопированного объекта по новому адруссу
    };
};


// функция копирует объект, поэтому для нее тоже создается конструктор дуструктор и конструктор копирования
void MultyCoordinate(Point point){ // функция будет умножать координаты на 2 только координату х
    // передвается копия объекта, когда мы его скопировали, сам объект и его свойства не изменятся
    point.setX(point.GetX()*2);
    cout <<" Coordinate x " << point.GetX()<< endl;
}

int main() {
    Point a(2,2,1);
    Point b(-2,1,-2);
    Point c(a); // объект с имеет другие данные под другим указателем (  arg ) ?? здесь arg просто нигде не используется
    cout <<" Coordinate x " << a.GetX()<< endl;
    cout <<" Coordinate x " << b.GetX()<< endl;
    cout <<" Coordinate x " << c.GetX()<< endl;
    MultyCoordinate(a);
    cout <<" Coordinate x " << b.GetX()<< endl;
    cout <<" Coordinate x " << c.GetX()<< endl;

    return 0;
}
